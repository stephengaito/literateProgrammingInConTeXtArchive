% A ConTeXt document [master document: literateProgs.tex]

\startchapter[title=The capture and manipulation of code]

All of our literate programming code capture environments are enhanced 
versions of the \ConTeXt\ \type{typing} environment. When creating 
\quote{standard} \ConTeXt\ environments the two commands, 
\type{\defineXXX} and \type{\setupXXX}, are critical to their overall use. 

\startTestSuite[defineLitProgs]

We begin by defining the \type{\defineLitProgs} command. This command is a 
simple enhancement of the \type{\definetyping} command, so we, 
essentially, define the \type{\defineLitProgs} command to call the 
\type{\definetyping} command.

However, the \type{\definetyping} command takes a variable number of up to 
three of arguments. This means that our definition of 
\type{\defineLitProgs} must also be able to deal with the same number of 
variable arguments. We use \ConTeXt's \type{\dotripleempty} command to 
provide the simplest and most explicit way of dealing with up to three 
variable arguments. A side-effect of our explicit pattern is that we 
provide the user with more appropriate error messages. 

The \type{\dotripleempty} command scans the token stream expecting a 
command plus up to three \quote{[} \quote{]} delimited arguments. It then 
sets one of the \type{\ifXXXargument} tests to true, depending upon how 
many arguments it has found. The \quote{real} work gets done in either the 
\type{\doDefineLitProgsSingle}, \type{\doDefineLitProgsDouble} or 
\type{\doDefineLitProgsTriple} commands, which explicitly expect either 
one, two or three arguments respectively. The \type{\doDefineLitProgsZero} 
command provides an appropriate error message, if the user has provided no 
arguments. The \type{\doDefineLitProgs} command simply manages the choice 
of the appropriate \type{\doDefineLitProgsXXX} command. 

Since we are enhancing the \type{typing} environment using lua code, the 
\type{\doDfineLitProgsSingle}, \type{\doDefineLitProgsDouble} and 
\type{\doDefineLitProgsTriple} commands make use of the 
\type{\fixStartLitProgs} and \type{\fixStopLitProgs} commands to layer in 
our enhancements. These two commands will be defined below. Similarly, we 
need to define a setup command corresponding to our new code type. We do 
this using the \type{defineLitProgsSetup} command, also to be defined 
below. Finally for each code type we would like a corresponding 
\type{createXXXFile} macro to write the accumulated text for a given code 
type out into a file. 

% see: http://wiki.contextgarden.net/Commands_with_optional_arguments

\startMkIVCode
\unexpanded\def\defineLitProgs{%
  \dotripleempty\doDefineLitProgs%
}

\unexpanded\def\doDefineLitProgs[#1][#2][#3]{%
  \ifthirdargument%
    \doDefineLitProgsTriple{#1}{#2}{#3}%
  \else\ifsecondargument%
    \doDefineLitProgsDouble{#1}{#2}%
  \else\iffirstargument%
    \doDefineLitProgsSingle{#1}%
  \else%
    \doDefineLitProgsZero%
  \fi\fi\fi%
}

\unexpanded\def\doDefineLitProgsTriple#1#2#3{
  \definetyping[#1][#2][#3]
  \fixLitProgs{#1}
}

\unexpanded\def\doDefineLitProgsDouble#1#2{
  \definetyping[#1][#2]
  \fixLitProgs{#1}
}

\unexpanded\def\doDefineLitProgsSingle#1{
  \definetyping[#1]
  \fixLitProgs{#1}
}

\unexpanded\def\doDefineLitProgsZero{
  \errmessage{
    \string\\defineLitProgs
    requires at least one argument,
    you have provided none.
  }
}
\stopMkIVCode

\startTestCase[should call all associated macros]

We assert that the \type{\defineLitProgs} macro actually defines all of 
the required macros. 

\startConTest
\begingroup
  \mockContextMacro{doDefineLitProgs}{3}
  \defineLitProgs[TestCode]
  \assertMacroExpanded{doDefineLitProgs}{}
\endgroup
\stopConTest

\startConTest
\begingroup
  \traceContextMacro{doDefineLitProgs}{3}
  \mockTexMacro{doDefineLitProgsTriple}{3}
  \mockTexMacro{doDefineLitProgsDouble}{2}
  \mockTexMacro{doDefineLitProgsSingle}{1}
  \mockTexMacro{doDefineLitProgsZero}{0}
  \firstargumentfalse
  \secondargumentfalse
  \thirdargumentfalse
  \assertNoFirstArgument{first}
  \assertNoSecondArgument{first}
  \assertNoThirdArgument{first}
  \defineLitProgs[AFirstArg]
  \assertFirstArgument{second}
  \assertNoSecondArgument{second}
  \assertNoThirdArgument{second}
  \assertMacroExpanded{doDefineLitProgsSingle}{}
\endgroup
\stopConTest

\startConTest
\begingroup
  \mockTexMacro{fixLitProgs}{1}
  \defineLitProgs[TestCode]
  \assertDefined{startTestCode}{}
  \assertDefined{stopTestCode}{}
  \assertMacroExpanded{fixLitProgs}{}
\endgroup
\stopConTest

\stopTestCase

\startTestCase[should define associated marcros]

\startConTest
\begingroup
  \defineLitProgs[TestCode]
  \assertDefined{startTestCode}{}
  \assertDefined{stopTestCode}{}
\endgroup
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[fixing literate programming environments]

Having provided the \ConTeXt\ code required to deal with variable 
arguments, we now need to provide the code required to \quote{fix} the 
\type{\startXXX} and \type{\stopXXX} commands automatically generated by 
the \type{\defintyping} command. We do this with the \type{\fixLitProgs} 
command. 

This command essentially \quote{wraps} the original \type{\startXXX} and 
\type{\stopXXX} commands with calls to an appropriate lua function 
(defined below). To do this our \quote{fix} command \type{\let}'s an 
\type{\oldXXX} command to \emph{be} the original command, and then 
redefine the original command to make the call into the lua code and then 
call the new \type{\oldXXX} command. Order here is critical as the 
\type{typing} environment is scanning for the exact token \type{\stopXXX}. 
Since all of these new commands are generated from the user's supplied 
code name, we make use of the Literate Programming Lua Renderer to 
dynamically build the required commands. 

A final complication is that our \type{\startXXX} command can take an 
optional argument which specifies a particular stream of code. If this 
optional argument is not provided, the 'default' stream will be used. We 
use an explicit variable argument pattern similar to that used to define 
\type{\defineLitProgs} above. Note that for the \type{\stopXXX} command 
things are simpler since the \type{\stopXXX} command takes no arguments. 

Finally, we need a code file creation command for each code type, 
\type{\createXXXFile}. This command takes two explicit arguments, the 
first argument is the name of the code stream, this is the same string as 
used in any of the corresponding \type{\startXXX} commands. The second 
argument is the name of the code file to be created. 

With these objectives in mind, we define the following Lua Template:

\startLuaTemplate
addTemplate(
  'fixLitProgs',
  { 'litProgsName' },
[=[
\let\oldStart{{= litProgsName }}=\start{{= litProgsName }}
\unexpanded\def\start{{= litProgsName }}{%
  \directlua{
    thirddata.literateProgs.markCodeOrigin(
      '{{= litProgsName }}'
    )
  }%
  \oldStart{{= litProgsName }}%
}
\let\oldStop{{= litProgsName }}=\stop{{= litProgsName }}
\unexpanded\def\stop{{= litProgsName }}{%
  \oldStop{{= litProgsName }}%
  \directlua{
    thirddata.literateProgs.addCodeDispatcher(
      '{{= litProgsName }}',
      '_typing_'
    )
  }
}
\unexpanded\def\create{{= litProgsName }}File#1#2#3{%
  \directlua{
    thirddata.literateProgs.createCodeFile(
      '{{= litProgsName }}',
      '#1',
      '#2',
      '#3'
    )
  }
}
\unexpanded\def\set{{= litProgsName }}Stream#1{%
  \directlua{
    thirddata.literateProgs.setCodeStream(
      '{{= litProgsName }}',
      '#1'
    )
  }
}
\unexpanded\def\prepend{{= litProgsName}}#1{%
  \directlua{
    thirddata.literateProgs.setPrepend(
      '{{= litProgsName }}',
      '#1',
      true
    )
  }
}
\unexpanded\def\append{{= litProgsName}}#1{%
  \directlua{
    thirddata.literateProgs.setPrepend(
      '{{= litProgsName }}',
      '#1',
      false
    )
  }
}
]=]
)
\stopLuaTemplate

We now define the Lua method, \type{createFixLitProgs}, which is required 
to drive the renderer. 

\startLuaCode
local function createFixLitProgs(theLitProgsName, aTracingOn)
  local theEnv = {
    litProgsName = theLitProgsName,
    tracingOn    = aTracingOn
  }
  local templatePath = litProgs.parseTemplatePath('fixLitProgs', theEnv)
  local theTemplate  = litProgs.navigateToTemplate(templatePath)
  local result       = litProgs.renderer(theTemplate, theEnv, true)
  result             = litProgs.splitString(result)
  tex.print(result)
  return result
end

litProgs.createFixLitProgs = createFixLitProgs
\stopLuaCode

We now define the \ConTeXt\ macro which will drive the whole process 
required to fix a new Literate Programs environment. 

\startMkIVCode
\def\fixLitProgs#1{%
  \directlua{thirddata.literateProgs.createFixLitProgs('#1')}
}
\stopMkIVCode

\startTestCase[createFixLitProgs should create the correct macros]

\startLuaTest
local createFixLitProgs = thirddata.literateProgs.createFixLitProgs

local macroBody = createFixLitProgs('Test')
assert.isTable(macroBody)
assert.length(macroBody, 55)
assert.isEqual(macroBody[1],  "\\let\\oldStartTest=\\startTest")
assert.isEqual(macroBody[2],  "\\unexpanded\\def\\startTest{%")
assert.isEqual(macroBody[3],  "  \\directlua{")
assert.isEqual(macroBody[4],  "    thirddata.literateProgs.markCodeOrigin(")
assert.isEqual(macroBody[5],  "      'Test'")
assert.isEqual(macroBody[6],  "    )")
assert.isEqual(macroBody[7],  "  }%")
assert.isEqual(macroBody[8],  "  \\oldStartTest%")
assert.isEqual(macroBody[9],  "}")
assert.isEqual(macroBody[10], "\\let\\oldStopTest=\\stopTest")
assert.isEqual(macroBody[11], "\\unexpanded\\def\\stopTest{%")
assert.isEqual(macroBody[12], "  \\oldStopTest%")
assert.isEqual(macroBody[13], "  \\directlua{")
assert.isEqual(macroBody[14], "    thirddata.literateProgs.addCodeDispatcher(")
assert.isEqual(macroBody[15], "      'Test',")
assert.isEqual(macroBody[16], "      '_typing_'")
assert.isEqual(macroBody[17], "    )")
assert.isEqual(macroBody[18], "  }")
assert.isEqual(macroBody[19], "}")
assert.isEqual(macroBody[20], "\\unexpanded\\def\\createTestFile#1#2#3{%")
assert.isEqual(macroBody[21], "  \\directlua{")
assert.isEqual(macroBody[22], "    thirddata.literateProgs.createCodeFile(")
assert.isEqual(macroBody[23], "      'Test',")
assert.isEqual(macroBody[24], "      '#1',")
assert.isEqual(macroBody[25], "      '#2',")
assert.isEqual(macroBody[26], "      '#3'")
assert.isEqual(macroBody[27], "    )")
assert.isEqual(macroBody[28], "  }")
assert.isEqual(macroBody[29], "}")
assert.isEqual(macroBody[30], "\\unexpanded\\def\\setTestStream#1{%")
assert.isEqual(macroBody[31], "  \\directlua{")
assert.isEqual(macroBody[32], "    thirddata.literateProgs.setCodeStream(")
assert.isEqual(macroBody[33], "      'Test',")
assert.isEqual(macroBody[34], "      '#1'")
assert.isEqual(macroBody[35], "    )")
assert.isEqual(macroBody[36], "  }")
assert.isEqual(macroBody[37], "}")
assert.isEqual(macroBody[38], "\\unexpanded\\def\\prependTest#1{%")
assert.isEqual(macroBody[39], "  \\directlua{")
assert.isEqual(macroBody[40], "    thirddata.literateProgs.setPrepend(")
assert.isEqual(macroBody[41], "      'Test',")
assert.isEqual(macroBody[42], "      '#1',")
assert.isEqual(macroBody[43], "      true")
assert.isEqual(macroBody[44], "    )")
assert.isEqual(macroBody[45], "  }")
assert.isEqual(macroBody[46], "}")
assert.isEqual(macroBody[47], "\\unexpanded\\def\\appendTest#1{%")
assert.isEqual(macroBody[48], "  \\directlua{")
assert.isEqual(macroBody[49], "    thirddata.literateProgs.setPrepend(")
assert.isEqual(macroBody[50], "      'Test',")
assert.isEqual(macroBody[51], "      '#1',")
assert.isEqual(macroBody[52], "      false")
assert.isEqual(macroBody[53], "    )")
assert.isEqual(macroBody[54], "  }")
assert.isEqual(macroBody[55], "}")
\stopLuaTest
\stopTestCase

\startTestCase[all fixed macros should exist]

\startConTest
\begingroup
  \defineLitProgs[Test]
  \assertDefined{oldStartTest}{}
  \assertDefined{startTest}{}
  \assertDefined{oldStopTest}{}
  \assertDefined{stopTest}{}
  \assertDefined{createTestFile}{}
  \assertDefined{setTestStream}{}
  \assertDefined{prependTest}{}
  \assertDefined{appendTest}{}
\endgroup
\stopConTest
\stopTestCase

We now turn to the lua code used in the \type{\directlua} commands above. 
As defined in the preamble, \type{litProgs} and \type{code} are variables 
local to the \type{t-literateProgs.lua} file. They provide access to the 
collection of lua functions and code fragments respectively. 

\startLuaCode
local function setOriginMarker(aCodeType, aCodeStream, anOriginMarker)
  if type(litProgs[anOriginMarker]) == 'function' then
    local codeType  = setDefs(code, aCodeType)
    if aCodeStream then
      local codeStream = setDefs(codeType, aCodeStream)
      codeStream['markOrigin'] = litProgs[anOriginMarker]
    else
      codeType['markOrigin'] = litProgs[anOriginMarker]
    end
  end
end

litProgs.setOriginMarker = setOriginMarker

local function markCodeOrigin(aCodeType)
  local codeType         = setDefs(code, aCodeType)
  local aCodeStream      = setDefs(codeType, 'curCodeStream', 'default')
  local codeStream       = setDefs(codeType, aCodeStream)
  codeStream.fileName    = status.filename
  codeStream.startLine   = status.linenumber
  tex.print({
   '\\blank[medium]\\noindent',
   '{\\darkgray '..aCodeType..' : '..aCodeStream..'}',
   ''
   })
end

litProgs.markCodeOrigin = markCodeOrigin

local function setCodeStream(aCodeType, aCodeStream)
  local codeType         = setDefs(code, aCodeType)
  aCodeStream            = aCodeStream or 'default'
  codeType.curCodeStream = aCodeStream
end

litProgs.setCodeStream = setCodeStream

local function setPrepend(aCodeType, aCodeStream, setValue)
  local codeType         = setDefs(code, aCodeType)
  aCodeStream            = aCodeStream or 'default'
  codeType.curCodeStream = aCodeStream
  local codeStream       = setDefs(codeType, aCodeStream)
  codeStream.prepend     = setValue
end

litProgs.setPrepend = setPrepend

local function addCodeDispatcher(aCodeType, bufferName)
  local bufferContents  =
    buffers.getcontent(bufferName):gsub("\13", "\n")

  if litProgs.addCode[aCodeType] ~= nil then
    litProgs.addCode[aCodeType](bufferContents)
  else
    litProgs.addCode.default(aCodeType, bufferContents)
  end
end

local function addCodeDefault(aCodeType, bufferContents)
  local codeType        = setDefs(code, aCodeType)
  local aCodeStream     = setDefs(codeType, 'curCodeStream', 'default')
  local codeStream      = setDefs(codeType, aCodeStream)

  local codeOrigin      = nil
    if type(codeStream['markOrigin']) == 'function' then
      codeOrigin =
        codeStream['markOrigin'](codeStream, aCodeType, aCodeStream)
    elseif type(codeType['markOrigin']) == 'function' then
      codeOrigin =
        codeType['markOrigin'](codeStream, aCodeType, aCodeStream)
    end

  if codeStream.prepend then
    tInsert(codeStream, 1, bufferContents)
    if codeOrigin then 
      tInsert(codeStream, 1, codeOrigin)
    end
  else
    if codeOrigin then
      tInsert(codeStream, codeOrigin)
    end
    tInsert(codeStream, bufferContents)
  end
  codeStream.prepend = nil
end

litProgs.addCodeDispatcher = addCodeDispatcher
litProgs.addCode           = {}
litProgs.addCode.default   = addCodeDefault
\stopLuaCode

\startMkIVCode
\unexpanded\def\setLitProgsOriginMarker{%
  \dotripleempty\doSetLitProgsOriginMarker%
}

\unexpanded\def\doSetLitProgsOriginMarker[#1][#2][#3]{%
  \ifthirdargument%
    \directlua{
      thirddata.literateProgs.setOriginMarker('#1', '#2', '#3')
    }
  \else\ifsecondargument%
    \directlua{
      thirddata.literateProgs.setOriginMarker('#1', nil, '#2')
    }
  \else\iffirstargument%
    \errmessage{
      \string\\setLitProgsOriginMarker
      requires at least two arguments,
      you have only provided one.
    }
  \else%
    \errmessage{
      \string\\setLitProgsOriginMarker
      requires at least two arguments,
      you have provided none.
    }
  \fi\fi\fi%
}
\stopMkIVCode

\startTestCase[should be able to collect code]

We use a LuaConTest to ensure that the \type{TestCode} environment 
captures its contents. 

\startConTest
\begingroup
  \defineLitProgs[TestCode]
  \traceContextMacro{doStartTestCode}{1}
  \startTestCode
    this is some test "code"
  \stopTestCode
  \startLuaConTest
    local code = thirddata.literateProgs.code
    assert.isNotNil(code['TestCode'], 'code')
    assert.isEqual(code['TestCode'].curCodeStream, 'default')
    code = code['TestCode']
    assert.isNotNil(code['default'], 'TestCode')
    code = code['default']
    assert.length(code, 1)
    assert.isEqual(code[1], 'this is some test "code"')
  \stopLuaConTest
\endgroup
\stopConTest
\stopTestCase

\startTestCase[should be able to collect code using addTestCodeCode]

We use a LuaConTest to ensure that the \type{TestCode} environment 
captures its contents using a specific addTestCodeCode Lua function. 

\startConTest
\begingroup
  \defineLitProgs[TestCode]
  \directlua{
    local function addTestCode(bufferContents)
      thirddata.literateProgs.testCodeAdded = true
    end
    thirddata.literateProgs.addCode.TestCode = addTestCode
  }
  \traceContextMacro{doStartTestCode}{1}
  \startTestCode
    this is some test "code"
  \stopTestCode
  \startLuaConTest
    assert.isTrue(thirddata.literateProgs.testCodeAdded)
  \stopLuaConTest
\endgroup
\stopConTest
\stopTestCase

\startLuaCode
local function createCodeFile(aCodeType,
                              aCodeStream,
                              aFilePath,
                              aFileHeader)
  if not build.buildDir then
    texio.write('\nERROR: document directory NOT yet defined\n')
    texio.write('       NOT creating code file ['..aFilePath..']\n\n')
    return
  end

  local theCode = code[aCodeType]
  if #aCodeStream < 1 then aCodeStream = 'default' end
  if theCode then theCode = theCode[aCodeStream] end

  if not theCode then
    texio.write('\nERROR: no code found for code stream ['..aCodeStream..'] and code type ['..aCodeType..']\n\n')
    return
  end
  if #aFilePath < 1 then
    texio.write('\nERROR: no file name provided for code type ['..aCodeType..']\n\n')
    return
  end

  build.srcTargets = build.srcTargets or { }
  tInsert(build.srcTargets, aFilePath)
  aFilePath = build.buildDir .. '/build/' .. aFilePath
  local outFile = io.open(aFilePath, 'w')
  if outFile then
    texio.write('creating code file: ['..aFilePath..']\n')
    if 0 < #aFileHeader then
      if aFileHeader:match('[Cc][Oo][Nn][Tt][Ee][Xx][Tt]') then
        outFile:write('% ')
      elseif aFileHeader:match('^!/.*bin') then
        outFile:write('#')
      end
      outFile:write(aFileHeader)
      outFile:write('\n\n')
    end
    outFile:write(tConcat(theCode, '\n\n'))
    outFile:close()
  else
    texio.write("\nERROR: could NOT open ["..aFilePath.."]\n")
  end
end

litProgs.createCodeFile = createCodeFile
\stopLuaCode

\stopTestSuite

We now make use of the newly defined \type{\defineLitProgs} macro to 
define a number of standard litterate programming environments: 
\type{MkIVCode}, \type{LuaCode}, \type{LuaTemplate}, \type{CHeader}, 
\type{CCode} and \type{Lmsfile}. 

However before we do this we need to provide a uniform way to denote code 
contexts by using \ConTeXt\ text backgrounds. 

\startMkIVCode
\definetextbackground[LitProgFrame]
\setuptextbackground%
  [LitProgFrame]%
  [location=paragraph, background=color, backgroundcolor=gray]
\stopMkIVCode

Using this newly defined \type{LitProgFrame} we now define our standard 
litterate programming environments. 

\startMkIVCode
\defineLitProgs%
  [MkIVCode]%
  [ option=context, numbering=line,
    before={\noindent\startLitProgFrame}, after=\stopLitProgFrame
  ]

\defineLitProgs%
  [LuaCode]%
  [option=lua, numbering=line,
    before={\noindent\startLitProgFrame}, after=\stopLitProgFrame
  ]

\defineLitProgs%
  [LuaTemplate]%
  [option=lua, numbering=line,
    before={\noindent\startLitProgFrame}, after=\stopLitProgFrame
  ]

\defineLitProgs%
  [CHeader]%
  [option=cpp, numbering=line,
    before={\noindent\startLitProgFrame}, after=\stopLitProgFrame
  ]

\defineLitProgs%
  [CCode]%
  [option=cpp, numbering=line,
    before={\noindent\startLitProgFrame}, after=\stopLitProgFrame
  ]

\defineLitProgs%
  [Lmsfile]%
  [option=lua, numbering=line,
    before={\noindent\startLitProgFrame}, after=\stopLitProgFrame
  ]

\setLitProgsOriginMarker[MkIVCode][markMkIVCodeOrigin]
\setLitProgsOriginMarker[LuaCode][markLuaCodeOrigin]
\setLitProgsOriginMarker[LuaTemplate][markLuaTemplateOrigin]
\setLitProgsOriginMarker[CHeader][markCHeaderOrigin]
\setLitProgsOriginMarker[CCode][markCCodeOrigin]
\stopMkIVCode

For \type{CHeader}s, we need to create the standard \type{#include} guard. 
We do this using the \type{\CHeaderIncludeGuard} macro as follows. 

\startMkIVCode
\def\CHeaderIncludeGuard#1#2{
  \directlua{
    thirddata.literateProgs.cHeaderIncludeGuard('#1', '#2')
  }
}
\stopMkIVCode

\startLuaCode
local function cHeaderIncludeGuard(aCodeStream, aGuard)
  setCodeStream('CHeader', aCodeStream)
  markCodeOrigin('CHeader')
  setPrepend('CHeader', aCodeStream, true)
  local bufferContents = [=[
#ifndef ]=]..aGuard..[=[_H
#define ]=]..aGuard..[=[_H
]=]
  addCodeDefault('CHeader', bufferContents)
  setPrepend('CHeader', aCodeStream, false)
  bufferContents = '#endif'
  addCodeDefault('CHeader', bufferContents)
end

thirddata.literateProgs.cHeaderIncludeGuard = cHeaderIncludeGuard
\stopLuaCode

% Do we need the following?

% Having defined a new code type in the previous section, we now have the 
% very much simpler task of providing a \type{\setupXXX} command. At the 
% moment we do not provide any extra options other than those provided by 
% the \type{\setuptyping} command. This means that all we have to do is to 
% define the \type{\setupXXX} to be a simple call to the 
% \type{\setuptyping} command. In all cases the \type{\setupXXX} will have 
% a single manditory argument which provides the collection 
% \type{\setuptyping} options to be used by this code type. 

%\startMkIVCode
%\def\defineLitProgsSetup#1{%
%  \def\csname setup#1\endcsname{%
%    \setuptyping[#1]%
%  }
%}
%\stopMkIVCode

\section{Test case results}

\reportMkIVStats

\reportLuaStats

\reportFailures

\stopchapter
